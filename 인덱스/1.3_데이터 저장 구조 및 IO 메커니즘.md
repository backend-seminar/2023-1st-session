> SQL 튜닝은 곧 I/O 튜닝이라 해도 과언이 아니다.

SQL이 느린 이유
-
- SQL이 느린 이유는 십중팔구 디스크 I/O 때문이다.
- 전반적으로 I/O 튜닝이 되지 않은 경우, 수많은 프로세스에 의해 동시다발적으로 I/O Call이 발생한다. 디스크 경합이 심해지고 그만큼 느려진다.

데이터베이스 저장구조
-
- 블록: 데이터를 읽고 쓰는 단위
- 익스텐트: 공간을 확장하는 단위, 연속된 블록의 집합
- 세그먼트: 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
- 테이블 스페이스: 세그먼트를 담는 컨테이너
- 테이터 파일: 디스크 상의 물리적인 OS 파일

블록단위 I/O
-
- 블록은 DBMS가 데이터를 읽고 쓰는 단위이다.
- 데이터 I/O단위가 블록이므로, 특정 레코드 하나만 읽고 싶어도 해당 블록을 통째로 읽어야 한다.
- 테이블, 인덱스 등에서 블록 단위로 I/O가 일어난다는 개념은 매우 중요하다.

시퀀셜 엑세스, 랜덤 엑세스
-
- 시퀀셜 엑세스
  - 시퀀셜 엑세스는 논리적 혹은 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다.
  - 인덱스 리프는 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어 있다.
  - 이 주소값에 따라 앞뒤로 순차적으로 스캔하는 방식이 시퀀셜 엑세스이다.
  - 테이블의 블록간에는 논리적 연결고리를 가지고 있지 않다.
  - 오라클의 경우, 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리한다. 익스텐트 맵은 각 익스텐트의 첫번째 블록 주소값을 가진다. 첫번째에 연결된 블록 뒤에 연속해서 저장된 블록을 읽으면 곧, Full-Table-Scan이 된다.
- 랜덤 엑세스
  - 랜덤 엑세스는 논리적, 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

논리적 I/O, 물리적 I/O
-
- DB 버퍼 캐시
  - 디스크 I/O가 SQL 성능을 결정한다. 자주 읽는 블록을 매번 디스크에서 읽는 것은 비효율이다. 따라서 캐시가 필요하다.
  - DB 버퍼 캐시는 SGA의 중요 구성요소이다.
  - 라이브러리 캐시가 SQL과 실행계획, 프로시저 등을 캐싱하는 코드캐시라면, DB 버퍼 캐시는 데이터 캐시이다.
  - 디스크에서 읽은 데이터 블록을 캐싱하여, 같은 블록에 대한 반복적인 I/O를 줄이는 것이 목적이다.
  - 버퍼 캐시는 공유메모리 영역으로 다른 프로세스도 이득을 본다.
- 논리적 I/O: SQL을 처리하는 과정에서 발생한 총 블록 I/O, 메모리 상의 버퍼 캐시를 경유하므로 메모리 I/O라고 보아도 무방하다(디스크를 읽기 전 조차, 한 번은 확인해야만 하므로).
- 물리적 I/O: SQL을 처리하는 과정에서 디스크에서 발생한 총 블록 I/O
- 버퍼캐시 히트율
  - BCHR: 전체 읽은 블록 중, 물리적 디스크 I/O를 수반하지 않고 메모리에서 바로 읽은 비율.
    1. (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록수) * 100 
    2. ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100 
    3. (1 - (물리적 I/O)/(논리적 I/O)) * 100
  - 물리적 I/O가 성능을 결정하지만, 결국 실제 SQL성능을 개선하기 위해서는 논리적 I/O를 줄여야 한다.
  - 논리적 I/O는 통제가 가능한 내생변수이다. 튜닝을 통해 읽는 총 블럭의 갯수를 줄이면 된다.
  - BCHR은 SQL의 성능을 좌우하지만, 반드시 효율을 의미하지는 않는다. 단순히 캐시가 히트했다는 것이며, 비효율적이게 같은 쿼리를 반복하는 경우 역시 극단적인 사례이지만 BCHR을 높일 수 있다.
  
Single Block I/O, Multi Block I/O
-
- Single Block I/O: 한 번의 Call에 하나의 블록을 요청하는 방식, 예) 인덱스를 이용한 인덱스와 테이블 조회
- Multi Block I/O: 한 번의 Call에 여러 블록을 요청하는 방식 예) 많은 데이터 블럭을 읽는 경우. 단, Multi Block I/O 역시 익스텐트의 경계를 넘지는 못한다.

Table Full Scan, Index Full Scan
-
- Table Full Scan이 성능을 떨어트린다는 인식과 달리, 인덱스 역시 적소에 쓰지 않으면 오히려 성능이 떨어진다.
- Table Full Scan은 시퀀셜 엑세스와 Multi Block I/O 방식으로, 한 블록의 모든 레코드를 읽고, 캐시에서 못찾으면 한 번의 Call로 인접한 수많은 데이터를 디스크에서 가져온다.
- Table Full Scan은 대량의 데이터에 강점을 가지지만 소량의 데이터는 인덱스를 사용하는 것이 좋다.
- Index Full Scan은 랜덤 엑세스와 Single Block I/O 방식을 사용한다.
- Index Full Scan은 많은 데이터를 읽을 때에는 불리하다. 인덱스는 큰 테이블에서 아주 작은 데이터를 빨리 찾기 위한 도구일 뿐이다.

캐시 탐색 메커니즘
-
- Direct Path I/O를 제외한 모든 블럭 I/O는 메모리 버퍼 캐시를 경유한다.
- 메커니즘
  - 같은 입력값은 항상 동일한 해시 체인에 연결된다.
  - 다른 입력값이 동일한 해시 체인에 연결될 수 있다.
  - 해시 체인 안에서는 정렬이 보장되지 않는다.

메모리 공유자원에 대한 엑세스 직렬화
-
- 버퍼 캐시는 SGA 구성요소로 캐싱된 버퍼블럭은 모두 공유자원이다. 문제는 하나의 버퍼 블럭에 어러 프로세스가 동시에 접근한다면 정합성 문제가 생길 수 있다는 것이다.
- 따라서 줄세우기 전략, 즉 직렬화 메커니즘이 필요하다.
- 그런데 직렬화 매커니즘에 의한 캐시 경합은 성능을 떨어트리기도 한다.
- 결국 캐시경합을 줄이기 위해서는, 다시 원론적인 이야기로 돌아와 논리적 I/O 자체를 줄여야한다.
