인덱스의 기본 사용법은 Range Scan하는 방법을 의미한다.

인덱스 컬럼(선두 컬럼)은 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
인덱스 컬럼을 가공하면 인덱스를 사용할 수는 있겠지만, 스캔 시작점을 찾을 수 없고 멈출수도 없어 Index Full Scan을 하게 된다.

인덱스를 Range Scan 할 수 없는 이유
-
인덱스를 가공하면 인덱스를 정상적으로 사용(Range Scan) 할 수 없다.

이유는 인덱스의 스캔 시작 지점을 찾을 수 없기 때문이다. 일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 한다.

인덱스를 Range Scan하기 위한 첫번째 조건은 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다는 것이다.

바꾸어 말해, 인덱스 선두 컬럼이 조건절에 있다면 인덱스는 반드시 실행된다. 문제는 정상적인 성능을 보장하지는 않는다는 것이다.

단 예외적으로 OR, IN과 같은 조건절은 옴티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 한다.

인덱스 잘 타니까 튜닝 끝?
-
- 일반적으로 "인덱스를 탄다"는 표현은 인덱스를 Range Scan한다는 의미이다.
- 인덱스가 "잘"타는지는 인덱스 리프 블럭에서 스캔하는 양을 따져봐야 한다.
- 스캔범위를 줄이지 못하는 인덱스는 제 역할을 하지 못한다.

인덱스를 이용한 소트 연산 생략
-
- 인덱스를 Range Scan 할 수 있는 이유는 정렬되어 있기 때문이다.
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만 찾고자 하는 데이터가 전체구간에 흩어지게 되기 때문에 비효율이 발생한다.
- 옵티마이저는 이런 인덱스의 특성을 이용해, 조건이 맞는다면 ORDER BY 연산이 있더라도 정렬연산을 수행하지 않는다.
- 오름차순, 내림차순 모두 해당된다. 인덱스 리프 블럭은 양방향 연결리스트 구조이기 때문이다.

ORDER BY 절에서의 컬럼 가공
-
- 조건절에 쓰인 인덱스 컬럼을 가공하면 정상적인 인덱스 처리가 불가능하다.
- 하지만 조건절이 아니더라도, 몇몇 케이스에서는 문제가 생기기도 한다.
- 예를 들어 Alias 이용에서 실수를 하여 가공된 값을 기준으로 ORDER BY 절을 사용하면 문제가 생길 수 있다.

SELECT-LIST에서 컬럼 가공
-
- 최댓값, 최솟값을 구할 때에도 옵티마이저는 정렬연산을 따로 수행하지 않는다.
- 하지만 MIN, MAX 함수 안에서 형변환(가공) 등이 일어난다면 문제가 일어날 수 있다.

자동 형변환
-
- 비교 연산시, 각 조건절에서 양쪽의 데이터 값의 데이터 타입이 다르면 값을 비교할 수 없다.
- 이때, 타입체크를 엄격히 하여 컴파일 시에 에러를 내는 DBMS도 있고, 자동으로 형변환을 해주는 DBMS도 있다.
- 하지만 비록 성능에는 문제가 없더라도, 형 변환 함수를 의도적으로 생략하는 것은 위험하다.
- 에러가 생길 수도 있고, 인덱스 효율에 문제가 생길 수도 있다.
-  자동형변환에 의존하지 않고 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 명확히 형변환 해주어야 한다.
