소프트 파싱, 하드 파싱
-
- 1. SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱하는 메모리 공간을 '라이브러리 캐시'라고 한다.
- 2. 라이브러리 캐시는 SGA(System Global Area)의 구성요소이다.
- 3. SGA는 서버 프로세스와 백그라운드 프로세스가 공통으로 엑세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간이다.
- 4. 사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱하고 해당 SQL이 라이브러리 캐시에 존재하는지 먼저 확인한다.
- 5. SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것을 *소프트 파싱*, 실패해  최적화 및 로우 소스 생성단계까지 모두 거치는 것을 *하드 파싱*이라고 한다.

> 하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나이다. 이렇게 어려운 하드 파싱을 통해 생성한 내부 프로시저를 한 번만 사용한다면 매우 큰 비효율일 것이다. 라이브러리 캐시가 필요한 이유가 여기에 있다.

바인드 변수의 필요성
-
- 이름없는 SQL 문제
  - 사용자 정의 함수, 프로시저, 트리거, 패키지 등은 이름이 있다.
  - 하지만 SQL은 이름이 없다. Full Text가 이름의 역할을 한다.
  - 처음 실행할 때에 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재하여 재사용한다.
  - 캐시 공간이 부족하면 삭제하고, 이후 필요할 때 동일한 최적화 과정을 거쳐 캐시에 적재된다.
  - 사용자 정의 함수, 프로시저 등은 내용을 수정해도 이름이 있으므로 같은 프로그램이 무한 생성되지 않는다. 반면에 SQL은 이름이 없다. 텍스트의 작은 부분이라도 수정되면 새로운 객체가 생성된다.
  - DBMS에서 수행되는 모든 SQL이 완성된 것은 아니다. 개발 과정에서 수시로 변경되고, 일회성(ad hoc)도 많다. SQL은 특성상 이름을 붙여도 제 역할을 기대하기 힘들다. 또 이런 미완성 쿼리를 모두 저장하면 그 만큼 조회 성능이 떨어질 것이다.
- 공유 가능 SQL
  - 라이브러리 캐시에서 SQL문을 찾기 위한 키 값은 'SQL 문 자체'이다. 따라서 의미적으로 수 많은 SQL은 라이브러리 캐시에서 별도의 공간을 차지한다.
  - DBMS에 발생하는 대부분의 부하는 과도한 I/O 때문이다. 하지만 I/O가 거의 없더라도 동시다발적인 하드 파싱은 부하를 높인다.
  - 파라미터 Driven방식의 바인드 변수는 서로 다른 SQL문에 대해 매번 발생하는 하드 파싱을 방지해준다.
  - 파라미터 바인딩 방식의 SQL에 대한 하드파싱은 최초 1회 발생할 것이고, 이후에는 캐싱된 데이터를 공유하며 재사용한다.