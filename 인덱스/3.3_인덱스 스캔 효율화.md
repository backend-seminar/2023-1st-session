인덱스 탐색
-
- 수직적 탐색은 결국 스캔의 시작점을 찾는 과정이다.

인덱스 스캔 효율성
-
- 인덱스 선행컬럼(인덱스에서 상대적으로 앞에 걸린 컬럼)이 조건절에 없거나, '=' 조건이 아니면 인덱스 스캔과정에서 비효율이 발생한다.

액세스 조건과 필터 조건
- 
- 인덱스 엑세스 조건: 인덱스 스캔 범위를 결정하는 조건절. 인덱스 수직적 탐색을 통해 스캔의 시작점을 결정하는데에 영향을 미치고, 인덱스 리프블럭을 스캔하다가 어디서 멈출지를 결정하는 조건절이다.
- 인덱스 필터 조건: 테이블로 엑세스할 지를 결정하는 조건절이다. 인덱스를 이용하든 Full Scan을 하든, 테이블 엑세스 단계에서 처리되는 조건절은 모두 필터 조건이다. 테이블 필터 조건은 쿼리 수행을 다음단계로 전달하거나 최종 결과집합에 포함할지 여부를 결정한다.

비교연산자 종류와 컬럼 순서에 따른 군집성
-
- 테이블과 달리 인덱스에는 같은 값을 가지는 레코드들이 군집해있다. 
- 인덱스 컬럼을 앞쪽부터 누락없이 '='인 상태에서 첫번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 모여있다. 하지만 그 이하 조건을 만족하는 레코드는 모두 흩어진다.

인덱스 선행 컬럼이 등치(=)조건이 아닐 경우 생기는 비효율
-
- 인덱스 스캔의 효율성은 인덱스 컬럼을 조건절에 모두 들치조건으로 사용할 때에 가장 좋다.
- 리프블럭을 스캔하면서 읽은 레코드는 하나도 걸러지지않고 모두 테이블 엑세스로 이어지므로 인덱스 스캔 단계에서 비효율은 전혀 없다.
- 반면, 인덱스 선행 컬럼이 조건절에 없거나, 부등호, BETWEEN, LIKE와 같은 범위검색 조건이면 인덱스 스캔과정에서 비효율이 생긴다.
- 인덱스 선행 컬럼이 모두 등치조건일때, 필요한 범위만 스캔하고 멈출 수 있는 이유는, 조건을 만족하는 레코드가 모두 한데 모여있기 때문이다.

BETWEEN을 IN-LIST로 전환
-
- 범위검색 조건을 맨 마지막으로 옮기는 것이 가장 좋지만, 여의치 않다면 BETWEEN 조건을 IN-LIST로 바꾸는 것이 대안이 될 수 있다.
- IN-LIST의 갯수만큼 UNION-ALL 브랜치가 생성되고 각 브랜치마다 '='조건으로 검색하므로 선두컬럼에 BETWEEN을 사용하는 것과 같은 비효율이 사라진다.
- 주의할 점은 IN-LIST의 갯수가 많지 않아야 한다는 것이다. 자칫 수직적 탐색의 비용이 리프블록을 많이 스캔하는 비효율보다 커질 수 있다.
- 또 인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때에만 유용하다.
- BETWEEN을 IN-LIST로 전환할 때에는 데이터 분포나 수직적 탐색 비용을 꼭 따져 보아야 한다.

IN 조건은 "="인가?
-
- IN 조건은 "="이 아니다.
- IN 조건은 "="이 되기 위해서는 IN-LIST Iterator 방식으로 풀려야 한다.
- 그렇지 않다면, IN 조건은 필터조건이다.

BETWEEM과 LIKE 스캔 범위 비교
-
- 많은 개발자들이 LIKE를 선호한다. 이유는 편리하기 때문이다.
- BETWEEM와 LIKE는 둘 다 범위검색 조건으로, 비효율의 원리가 동일하게 적용된다. 하지만 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 다를 수 있다.
- 하지만 BETWEEM을 사용하는 것이 명시적이기 때문에 LIKE보다 낫다. 적어도 BETWEEM을 사용하면 손해는 안본다.

범위검색 조건을 남용할 때에 생기는 비효율
-
- 모든 조건절에 LIKE를 남용하면 엑세스조건이 필터조건으로 변하면서 인덱스 스캔 범위가 늘어나고 비효율이 발생할 수 있다.
- 모든 조건절에 BETWEEN을 남용하는 경우 역시 유사하다.
- 개발 생산성이 효율을 해칠 수 있다. 명시적으로 필요한 조건을 선언하는 것이 가장 좋다.
- SQL을 작성할 때에 주의해야하며, 데이터분포에 따라 인덱스 컬럼에 대한 비교 연산자를 신중하게 선택해야한다.

다양한 옵션 조건 처리 방식의 장단점 비교
-
- OR 조건 활용
  - 인덱스 선두 컬럼에 대한 OR 조건은 비효율을 발생시킨다.
  - OR 조건을 이용한 옵션조건 처리는 가능하면 사용하지 말아야 한다.
  - 이 방식의 유일한 장점은 옵션 조건 컬럼이 NULL 허용 컬럼이라도 결과집합을 보장한다는 것 뿐이다.
    - 인덱스 엑세스 조건으로 사용불가
    - 인덱스 필터 조건으로 사용불가
    - 테이블 필터 조건으로 사용가능
    - 단 인덱스 구성 컬럼 중, 하나 이상이 Not Null이면 인덱스 필터 가능
- LIKE/BETWEEN 조건 활용
  - 변별력이 좋은 필수 조건이 있는 상황에서 필수조건 칼럼을 인덱스 선두에 두고 엑세스조건으로 활용한다면 충분히 좋은 성능을 낼 수 있다.
  - 문제는 필수 조건의 변별력이 좋지 않을 때이다.
    - 인덱스 선두 컬럼에 대한 조건을 LIKE/BETWEEN으로 하는 것은 금물이다.
    - NULL 허용컬럼에 대한 옵션 조건을 LIKE/BETWEEN으로 처리 하는 것은 금물이다.(NULL 값이 있는 컬럼이 누락되어, 결과집합에 오류가 생긴다.)
    - 숫자형이면서 인덱스 액세스 조건으로도 사용가능한 컬럼에 대한 옵션조건 처리는 LIKE를 사용해서는 안된다.(자동 형변환으로 필터조건이 된다.)
    - LIKE를 옵션조건에 넣을때에는 컬럼 값 길이가 고정적이어야 한다.(결과집합에 오류가 있을 수 있다.)
- UNION ALL 활용
  - UNION ALL 방식은 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용한다는 사실이 매우 중요하다.
- NVL/DECODE 함수 활용
  - 옵티마이저 쿼리 변환이 일어나면 인덱스 컬럼 가공이 일어나더라도 인덱스를 사용할 수 있다.
  - 만약 이 기능이 작동하지 않으면 이 패턴도 인덱스 액세스 조건으로 활용이 불가능하다.

함수호출부하 해소를 위한 인덱스 구성
-
- PL/SQL 함수의 성능적 특성
  - PL/SQL 함수는 다음의 이유로 생각보다 느리다
    1. 가상머신 상에서 실행되는 인터프리터 언어
    2. 호출시 컨택스트 스위칭 비용 발생
    3. 테이블 건 수 만큼 내장 SQL에 대한 Recursive Call 발생
  - PL/SQL 엔진은 바이트코드를 런타임 시에 해석하면서 실행한다.
  - PL/SQL 역시 인터프리터 언어이기 때문에 Native로 완전 컴파일된 내장함수에 비해 많이 느리다.

- 효과적인 인덱스 구성을 통한 함수호출 최소화
  - 인덱스를 함수에 대해 설정하면, 해당 조건에 대한 횟수 만큼의 함수 호출을 감축할 수 있다.(단, 인덱스 필터 조건인지 인덱스 엑세스 조건인지에 따른 비용차이는 존재한다.) 