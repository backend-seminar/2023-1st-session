테이블 엑세스 최소화
-

- 테이블 랜덤 엑세스
  - 아무리 데이터가 많아도 인덱스를 사용하면 금방 조회할 수 있다.
  - 대량 데이터를 조회할 때에 인덱스를 사용하면 테이블 전체를 스캔할 때보다 훨씬 느리다.


- 인덱스 ROWID는 물리적 주소? 논리적 주소?
  - 인덱스를 스캔하는 이유는, 검색조건을 만족하는 소량의 데이터를 인덱스에서 빠르게 찾고 거기서 테이블 레토드를 찾아가기 위한 주소값, 즉 ROWID를 찾기 위해서이다.
  - 인덱스 ROWID는 논리적 주소에 가깝다. 물리적으로 직접 연결된 것이 아니라, 테이블 레코드를 찾아가기 위한 논리적 주소정보를 담고 있기 때문이다.


- 메인 메모리 DB와의 비교
  - 메인 메모리 DB는 데이터를 모두 메모리에 로드하고, 메모리를 통해서면 I/O를 수행힌디. 이때 인덱스는 포인터와 같이 O의 비용을 가진다.
  - 반면 일반적인 RDBMS에서는 히트율이 높더라도 테이블 블록이 수시로 버퍼캐시에서 밀려났다 다시 캐싱되는 과정을 반복한다. 따라서 인덱스를 포인터로 직접 연결할 수 없다.
  - 그래서 RDBMS에서 인덱스 ROWID를 이용한 테이블 엑세스가 생각보다(0 비용) 빠르지 않다.


- I/O 메커니즘 복습
  - DBA(데이터 파일번호 + 블록번호)는 디스크 상에서 블록을 찾기 위한 주소 정보이다.
  - 블록을 읽을 때, 디스크로 가지 전 버퍼캐시를 먼저 확인한다.
  - 읽고자 하는 DBA를 함수에 입력하고 해시 체인을 찾고, 버퍼 헤더를 찾는다.
  - 해싱 알고리즘으로 버퍼 헤더를 찾고 거기서 얻은 포인터로 버퍼 블럭을 찾아간다.
  - 설령 모든 데이터가 캐싱되었다고 해도, 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 반복해야 한다.
  - 동시 엑세스가 심한 경우라면 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합 역시 발생한다.
  - 인덱스 ROW ID를 이용한 테이블 엑세스는 생각보다 고비용 구조이다.

인덱스 클러스터링 팩터
-
- 클러스터링 팩터(CF):  특정 컬럼을 기준으로 같은 깂을 가지는 데이터가 서로 모여있는 정도를 의미한다. 


  - CF가 좋은 경우, 테이블 엑세스량에 비해 블록 I/O가 적게 발생한다.
  - 오라클은 래치획득과 해시체인스캔 과정에서 테이블 블록에 대한 포인터를 바로 해제하지 않고 일단 유지하는데 이를 버퍼라고 부른다. 만약 직전 레코드와 같은 테이블 블록을 가르킨다면 래치획득과 해시체인스캔 과정을 생략하고 바로 테이블 블록을 읽을 수 있다.

인덱스 손익 분기점
-
- 인덱스 ROW ID를 이용한 테이블 엑세스는 생각보다는 고비용 구조이다. 만약 읽어야 할 데이터가 일정량을 넘는다면 테이블 풀 스캔보다 오히려 느려진다.
- Table Full Scan은 성능이 일정하다. 반면 인덱스를 이용해 테이블을 엑세스할 때에는 전체 데이터 대비 몇건을 추출하느냐에 따라 성능이 크게 달라진다.
  - Table Full Scan은 시퀀셜 엑세스인 반면, 인덱스 ROW ID를 이용하는 경우 랜덤 엑세스이다.
  - Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROW ID를 이용하는 경우 Single Block I/O이다.
- 인덱스 CF가 나쁘면 같은 테이블 블럭을 반복 엑세스하며 논리적, 물리적 I/O가 늘게 된다. 


- 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝
  - 온라인 프로그램은 보통 소량의 데이터를 읽고 갱신하므로 인덱스와 NL조인 방식이 적절하다.
  - 반면 대량의 데이터를 읽고 갱신하는 배치 프로그램은 항상 전체범위 처리를 기준으로 튜닝해야 한다. 대량 데이터를 빠르게 처리하려면, 인덱스와 NL조인보다는 Full Scan과 해시조인이 유리하다.

인덱스 컬럼 추가
-
- 테이블 엑세스를 최소화하기 위해 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는 것이다.
- 이 경우는 테이블 엑세스 단계에서 필터 조건에 의해 버려지는 데이터가 많다면 유용하다.

인덱스만 읽고 처리
-
- 테이블의 랜덤 엑세스가 아무리 많아도 필터 조건에 의해 버려지는 레코드가 거의 없다면 비효율은 없다. 하지만 절대적인 일의 양이 많아 성능이 느린 경우도 있다.
- 이 경우 반드시 성능을 개선해야 한다면, 쿼리에 사용된 컬럼을 모두 인덱스에 추가하여 테이블 엑세스가 아예 발생하지 않도록 하는 방법이 있다.
- 인덱스만 읽어 처리하는 쿼리를 Covered 쿼리라고 하고, 그 쿼리에 사용된 인덱스를 Covered 인덱스라고 한다.
- 이 방법은 효과가 매우 좋지만, 추가해야할 컬럼이 많다면 현실적으로 적용하기 어려운 경우가 생길 수 있다.

인덱스 구조 테이블
- 
- 인덱스를 이용한 테이블 엑세스가 고비용 구조라면, 랜덤 엑세스가 발생하지 않도록 테이블을 애초에 인덱스 구조로 생성하는 방법을 생각할 수 있다.
- 이를 IOT(Index-Organized Table) 혹은 클러스터형 인덱스라고 부른다.

클러스터 테이블
-
- 인덱스 클러스터 테이블
  - 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조를 의미한다.
  - 한 블록에 모두 담을 수 없을 때에는 새로운 블럭을 할당해 클러스터 체인으로 연결한다.
  - 일반 테이블과는 달리, 여러 테이블의 레코드를 같은 블럭에 저장(공유)하는 '다중 테이블 클러스터' 방식도 가능하다.
  - B*Tree 인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터블럭을 가리킨다는 점이 다르다.
  - 테이블의 레코드와는 1:M관계를 가지며, 클러스터 인덱스의 키는 항상 Unique하다.
  - 클러스터 인덱스를 스캔하면서, 값을 찾는다면 랜덤엑세스가 한 번씩 밖에 생기지 않는다. 클러스터에 도달해서는 시퀀셜한 방식으로 값을 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다는 것이 핵심이다.
- 해시 클러스터 테이블
  - 해시 클러스터는 인덱스를 사용하지 않고, 해시 알고리즘을 사용해 클러스터를 찾아간다.