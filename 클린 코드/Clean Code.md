## 클린 코드란? 주의 깊게 작성한 코드
### 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 분리하자.

- 중복을 피하라
- 한 기능만 수행하라
- 제대로 표현하라
- 작게 추상화하라

내가 코드를 짜는 시간을 늘려 제대로 된 코드를 짠다면, 다른 사람들이 코드를 읽는 시간이 줄어든다. (조사 결과 개발자가 사용하는 시간 중 코드를 읽는 시간 : 코드를 짜는 시간의 비율은 10 : 1이다)
그러니 오늘 코드 짜는데에 충분한 시간을 들여서 이후의 시간을 줄이자.

## 목차
1. 의미 있는 이름
- 의미있게 구분하라 : 의미있는 구분을 사용하자. ~Data, ~Info 같이 불용어만 추가한 이름은 아무런 정보도 제공하지 못한다. 
- 발음하기 쉬운 이름을 사용하라 : genymdhms(generated year, month, day, hour,...) 금지
- 검색하기 쉬운 이름을 사용하라 
- 인코딩을 피하라 : phoneString 이라는 변수명 적절하지 않다!
- 기발한 이름은 피하라 : 농담을 메서드명에 넣지 마라
- 한 개념에 한 단어를 사용하라 : 메서드 이름은 독자적이고 일관적이어야 한다. 
- 의미 있는 맥락을 추가하되 불필요한 맥락을 없애라.
3. 함수
- 작게 만들어라 : 작게, 더 작게 만들어라. if문 / else 문 / while 문 등에 들어가는 블록은 한 줄 이어야 한다. + 블록 내에서 호출하는 함수 이름을 적절히 짓는다면 코드를 이해하기도 쉬워진다. 함수에서 들여쓰기 수준은 1, 2단을 넘어서면 안 된다.
- 한 가지만 해라 : 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다. 
- 함수 당 추상화 수준은 하나로 해라 : 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다 = 내려가기 규칙. 
- Switch 문 : 본질적으로 switch 문은 n가지를 처리한다. 완전히 피할 방법은 없지만 switch문을 저차원 클래스에 숨기고 절대로 반복하지 말자. 다형적 객체를 생성하는 코드 안에서의 switch문 정도만 참아주고 상속 관계에 숨긴 후에는 절대로 다른 코드에 노출하지 않는다. (가 원칙.. 근데 가끔 위반할 경우도 있다)
```java
public abstract class Employee {
  public abstract boolean isPayDay();
  public abstract Money calcPay();
  public abstract void deliverPay(Money pay);
}

public interface EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
    switch (r.type) {
      case COMMISSIONED:
        return new CommissionedEmployee(r);
      case HOURLY:
        return new HourlyEmployee(r);
      case SALARIED:
        return new SalariedEmployee(r);
      default:
        throw new InvalidEmployeeType(r.type);
    }
  }
}
```
- 서술적인 이름을 사용하라 : 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다. 길어도 된다. 
- 함수 인수 : 이상적인 인수 개수는 0개이다. 그 다음은 1개, 그 다음은 2개이다. 3개 이상은 피하는 게 좋다. 4개 이상은 특별한 이유가 있어야 하고, 특별한 이유가 있어도 사용하면 안 된다. 
- 플래그 인수 : 플래그 인수는 추하다!
```java
render(boolean isSuite) -> render(true)
```
- 부수 효과를 일으키지 마라 : 부수 효과는 거짓말이다. 한 가지를 하겠다고 하고 남몰래 다른 짓을 하기도 하고, 예상치 못하게 클래스 변수를 수정하기도 한다. 예를 들면 checkPassword() 메서드 내에서 비밀번호가 유효하지 않으면 세션을 초기화 시키는 역할을 한다면, 해당 메서드는 세션을 초기화해도 괜찮은 경우에만 호출이 가능하다. 의도하지 않게 세션을 날려버릴 수도 있다. 
- 명령과 조회는 분리해라 : 호출되는 함수만 보고는 username이 yeonju로 설정되어 있는지 확인하는 코드인지, 혹은 username을 yeonju로 설정하는 코드인지 확인하기가 어렵다. 
```java
public boolean set(String attribute, String value);
if (set("username", "yeonju")) ...
```
- 오류 코드보다 예외를 사용하라 `if (deletePage(page) == E_OK)`는 명령 조회 분리 규칙을 미묘하게 위반한다. 대신 try catch로 대체하라. 오류 코드를 반환한다는 것은 어디선가 오류 코드를 정의한다는 뜻이고 다른 클래스들에서 해당 오류 코드 클래스를 임포트하여 사용해야 하기 때문에 Error enum이 변한다면 Error enum을 사용하는 클래스 전부를 다시 컴파일하고 다시 배치해야 한다. 
- 반복하지 마라 : 중복된 코드가 작성되지 않도록 한 곳에서만 유지한다. 중복은 SW에서 모든 악의 근원이다. 
- 구조적 프로그래밍 : 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다. (그러나 함수를 작게 만든다면 괜찮다)
- 함수를 짤 때는, 글짓기처럼 먼저 생각을 기록하고 읽기 좋게 다듬는다. 서투른 코드를 빠짐없이 테스트 하는 단위 테스트 케이스도 만든다. 그리고 다듬고 함수를 만들고 이름을 바꾸고 중복을 제거한다. 한번에 잘 짜는 사람들은 없다. 

5. 오류 처리

- 오류 코드보다 예외를 사용하라
- Try-Catch-Finally 문부터 작성하라 > 트랜잭션처럼 사용하는 범위를 명확히 할 수 있다. 
- 미확인(Unchecked) 에러를 사용하라 (Checked Exception이 반드시 필요하지 않다 > 오히려 OCP를 위반. 하위 단계에서 코드를 수정했는데 상위 단계 메서드 선언부에서 전부 수정해야 함. 캡슐화 깨짐 )
- 예외에 의미를 제공하라 (기본 제공되는 스택트레이스 외에도 정보를 담아서 같이 던지자)
- 오류를 정의할 땐 오류를 잡아내는 방법을 고려해라. (외부 API를 사용한다면 발생 가능한 예외를 감싸서 던질 수 있는 예외를 만든다. + 발생 가능한 모든 예외를 해당 예외로 감싸서 사용한다.)
- 정상 흐름으로 정의하라 (중요한 듯)
- null을 반환하지 마라 (null 반환은 호출자에게 문제를 떠넘기는 일!)
- null을 전달하지 마라
8. 경계 (외부 코드 - 패키지, 오픈 소스, 다른 팀의 컴포넌트 등-를 우리 코드에 깔끔하게 통합시켜야 한다)
- 외부 코드 사용하기 (Map이 위험이 크다 > 제네릭스를 사용하면 가독성이 높아지지만, 사용자에게 필요하지 않은 기능까지 제공한다(=clear())는 문제나 Map 인터페이스가 변할 경우 수정할 코드가 많아진다는 단점은 존재한다. Map 인터페이스를 공개 API에 넘기거나 반환값으로 사용하지 말자!)
- 경계 살피고 익히기 (외부 코드를 익히기와 통합하기는 어려우니 간단한 테스트 케이스를 작성해 외부 코드를 익히자 = 학습 테스트)
- log4j 익히기 
- 아직 존재하지 않는 코드를 사용하기 (외부 코드의 구체적인 구현내용을 모른다면 우선 인터페이스와 메서드 명을 정의하여 외부 코드가 사용되는 부분을 비워두고 우선 사용한다)
- 깨끗한 경계 (경계에 위치한 코드는 깔끔하게 분리한다)
9. 단위 테스트
- TDD 법칙 세 가지
```
1) 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2) 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3) 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
```
- 깨끗한 테스트 코드 유지하기
- 테스트는 유연성, 유지보수성, 재사용성을 제공한다 > 단위 테스트를 통해 이러한 것들을 보장할 수 있다. 테스트 케이스가 있으면 변경이 쉬워진다. 
- 깨끗한 테스트 코드에 필요한 건 : 가독성. 
- 테스트 당 assert는 하나 : 테스트 코드를 읽기가 쉬워진다. 테스트 함수마다 한 개념만 테스트하라. 
- F.I.R.S.T
```
F : Fast (빠르게 돌아야 한다. 느리면.. 테스트 해보기 싫어짐)
I : Independent (각 테스트는 독립적으로, 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서도 안 된다. 한 테스트가 실패하면 다음 테스트도 실패하게 되므로, 어떤 테스트가 문제인지 알 수 없다)
R : Repeatable (반복 가능하게, 실제 환경, QA 환경, 혹은 버스 타고 집 가는 길에 사용하는 와이파이 없는 노트북 환경에서도 실행 가능해야 한다)
S : Self-Validating (테스트는 부울 값을 결과를 내야 한다. 성공 or 실패. 둘 밖에 없다. 명확하게 결과를 내야 한다.)
T : Timely (적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드 구현한 후에 테스트 코드를 작성하면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.) 
```
